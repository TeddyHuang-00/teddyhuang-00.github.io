---
title: 个人最爱项目
pubDatetime: 2023-04-08
modDatetime: 2025-09-01
tags:
  - CLI
  - Editor
  - DevTools
  - Font
  - Git
  - PackageManager
  - PDF
  - Productivity
  - Python
  - Rust
  - Shell
  - Streamlit
  - Tailwind
  - Terminal
  - Tools
  - TUI
  - Typst
  - VCS
  - Vue
  - Vuepress
  - Web
featured: true
draft: false
description: 收集一些我个人最爱的项目，以便日后查阅。时不时更新。
---

import { Aside, Badge, Ruby } from "@/components/content/components";

## 包管理器

### homebrew

<Aside type="info">

- 主页：[brew.sh](https://brew.sh/)
- GitHub 仓库：[homebrew/brew](https://github.com/homebrew/brew)

</Aside>

不需要多说，这是 macOS 上独一档的包管理器，已经成为了 macOS 上的标配，并且现在也正式整合了 Linuxbrew，可以在 Linux 上使用。

> 我相信 Ubuntu 的一大痛点就是 apt 源的更新速度会比较慢，追求稳定性的 Debian 更加，因此如果想要使用一些更新版本的软件，就需要自己编译安装，这对于一般用户来说是非常不友好的。
> 而由社区维护的 Homebrew 就可以很好地解决这个问题，可以很方便地安装一些最新版本的软件。
> 目前唯一遗憾的是暂时不支持 GUI 应用安装（对应 macOS 下的 cask）

> 其他的类似工具比如 [MPR](https://www.makedeb.org/) 或许也值得一试，但是我还没有尝试过，并且 Homebrew 在 Linux 和 macOS 上都能用，因此我还是更倾向于使用它。

### paru

<Aside type="info">

- GitHub 仓库：[Morganamilo/paru](https://github.com/Morganamilo/paru)

</Aside>

一个方便快速访问 AUR 的包管理器，支持从 AUR 安装软件包，并且提供了非常方便的命令行界面。
功能和 `yay` 类似，但是在命令行选项上更接近 `pacman`，可以很方便地参考 `pacman` 的教程，简单将 `pacman` 替换为 `paru` 即可。

> 这也是我在 Arch Linux 上的首选包管理器，使用起来非常顺手。
> 而且它是用~~语言神~~ Rust 写的，怎么能说不呢？

> ~~I use Arch BTW.~~

### uv

<Aside type="info">

- GitHub 仓库：[astral-sh/uv](https://github.com/astral-sh/uv)

</Aside>

一个用 Rust 编写的 Python 一条龙工具，包括 Python 版本管理、虚拟环境、pip 包管理、项目依赖管理等功能。
也支持类似于 `pipx` 的功能，可以直接安装和运行 Python 包。

- Python 版本管理方面，不仅能够完整抓取系统中的 Python 版本，还能方便地下载预编译的 Python 版本（同样支持按需安装，可以不用先安装再使用）。
- 虚拟环境方面，取代了 `virtualenv` 和 `venv`，提供了更加简单和一致的命令。
- pip 包方面，`uv` 提供了类似于 `pip` 的命令，可以方便地安装和管理 Python 包。
  同时有更好的版本解析，避免了依赖冲突的问题。（遇上~~不懂事~~没遵守[语义化版本](https://semver.org/lang/zh-CN/)的包，也可以手动覆盖依赖版本）
- 项目依赖管理方面，`uv` 提供了类似于 `poetry` 和 `conda` 的功能，可以帮助你在 `pyproject.toml` 中管理项目的依赖，并且生成 `uv.lock` 来锁定依赖版本，方便在不同环境中复现。~~（妈妈再也不用担心卸载 pip 包不干净了）~~

> 虽然 `uv` 并不能算是一个完整的包管理器，但鉴于其提供了完整的 Python 生态管理功能，还是把它放入这个类别下面了。

> 暴论一点，`uv` 应该成为 Python 生态的标准工具。
> 没有用过 `uv` 就不要说自己是 Python 开发者。😈

## 命令行界面

### fish

<Aside type="info">

- 主页：[fishshell.com](https://fishshell.com/)
- GitHub 仓库：[fish-shell/fish-shell](https://github.com/fish-shell/fish-shell)

</Aside>

一款用户友好的命令行 shell，默认提供了许多现代化的特性，如语法高亮、自动补全、命令建议等。
同时语法也比传统的 shell 更加简洁易懂，新增了许多功能强大的函数，写的脚本可读性非常高。

> 目前是我的主力 shell，还没有遇到 `fish` 不能解决或者不好解决，需要用回 `xonsh` 或者 `bash` 的情况。

> 相比于 `xonsh`，`fish` 虽然不支持 Python 语法，但是它自带的函数和特性足以满足大部分需求。

> 目前比较不满意的地方在于 `fish` 的插件生态比较薄弱。
> 似乎存在两套插件系统，分别是 `fisher` 和 `oh-my-fish`，暂时没有形成统一的标准。
> 不过 [`fisher`](https://github.com/jorgebucaran/fisher) 的发展势头不错，也兼容 `oh-my-fish` 的插件，未来可期。

### xonsh <Badge type="caution" text="不再推荐" />

<Aside type="info">

- 主页：[xon.sh](https://xon.sh/)
- GitHub 仓库：[xonsh/xonsh](https://github.com/xonsh/xonsh)

</Aside>

一款跨平台、基于 Python 的 shell，特点概括为四个：

1. 能用 shell
2. 能用 Python
3. 能在 shell 中用 Python
4. 能在 Python 中用 shell

因此可以用 Python 和 shell 很方便地进行交互，而且还能用 Python 的库，非常适合简单的自动化和调试等。
~~并且这几年来社区活跃度和受支持程度都在不断提高，应当是未来的主流 shell 之一。~~

> ~~这也是我的主力 shell，如果可以选，我一定会选用它。~~不再是我的主力 shell 了。

> 用了四年，感觉生态依然不够成熟，社区贡献增长缓慢，并且和一些主流工具如 `screen`、`tmux` 等的兼容性也有待提高。
> 因此我更推荐 [`fish`](#fish) 作为一个同样好用的替代品。

### starship

<Aside type="info">

- 主页：[starship.rs](https://starship.rs/)
- GitHub 仓库：[starship/starship](https://github.com/starship/starship)

</Aside>

一个支持多种 shell 的命令行提示符，提供了非常多的自定义选项，可以根据自己的喜好和需求进行配置。
现已经官方支持了 [xonsh](#xonsh)，而且还有很多社区提供的主题，可以直接使用。

由于基于 Rust，所以响应速度极快。
并且功能也比较丰富，提供对于当前目录下的 Git 仓库的支持，以及多种编程语言的项目版本识别等等。
反正用它就对了。

### Carapace

<Aside type="info">

- 主页：[carapace.sh](https://carapace.sh/)
- GitHub 仓库：[carapace-sh/carapace](https://github.com/carapace-sh/carapace)

</Aside>

一个强大的自动补全框架，不仅可以作为桥接器，同时使用写给不同 shell 的补全脚本，其二进制程序本身也包含了许多常用命令的补全（可以手动禁用来使用来自本地的补全）。

> 伟大，无需多言！基本开箱即用，和 `fish` 的兼容性也很高（部分得益于 `fish` 本身优秀的补全框架设计）。

> 偶尔可能遇到命令选项补全不准确的情况，一般是由于内置的补全信息不够完善。
> 通常只需要禁用该命令的补全，使用 `fish` 或其他 shell 提供的补全即可。

## 终端

### Ghostty

<Aside type="info">

- 主页：[ghostty.dev](https://ghostty.dev/)
- GitHub 仓库：[ghostty-org/ghostty](https://github.com/ghostty-org/ghostty)

</Aside>

期待许久的 Ghostty 在 2024 年圣诞终于发布了。
性能方面并没有像 `Alacritty` 那样追求极致的性能，而是更注重用户体验和可定制性，同时做到了几乎无感的延迟。

> 此前用过的终端最大的痛点就是在于要么各种拉胯（点名批评 `kitty`，不知道为什么甚至有人会推荐它），要么缺乏某些功能（`Alacritty` 至今还不支持连字符、图像协议等），要么 UI 太丑（🤡 `WezTerm`）或者没有跨平台支持（`iTerm2`：Only 🍎 can do）。

> Ghostty 目前满足我的所有需求，在做到跨平台的同时又尽量使用了平台原生的组件。
> 虽然没有认真测过响应速度，但是至少从我体感上来说是非常流畅的：和 `Alacritty` 相比，不管是冷启动还是字符输入，都没有可感知的差距。

### tmux

<Aside type="info">

- GitHub 仓库：[tmux/tmux](https://github.com/tmux/tmux)

</Aside>

一个强大的终端复用工具，可以在一个终端窗口中管理多个会话、多个窗口。
同时还有丰富的插件系统，可以通过 [Tmux Plugin Manager (tpm)](https://github.com/tmux-plugins/tpm) 轻松管理各种插件，实现功能拓展。

> 客观来说，`tmux` 的学习曲线相对 `screen` 而言较陡一些，但一旦掌握，便能极大提高工作效率。

> `tmux` 很好得解决了在 `screen` 中长期困扰我的问题，尤其是在字符支持、颜色支持、历史消息查看与复制等方面。
> 同时借由插件，`tmux` 还可以实现更多自定义功能，比如自动保存会话状态，恢复上次的会话等等，即便是重启也不怕会话丢失。

## 命令行工具

### vhs

<Aside type="info">

- GitHub 仓库：[charmbracelet/vhs](https://github.com/charmbracelet/vhs)

</Aside>

一个命令行录制工具，可以用非常简单的语法编写脚本来控制操作，轻松生成非常好看的 GIF 动图。

由于可以由脚本控制，因此非常适合命令行工具的演示，也可以作为命令行工具的测试工具。

### glow

<Aside type="info">

- GitHub 仓库：[charmbracelet/glow](https://github.com/charmbracelet/glow)

</Aside>

一个命令行 Markdown 阅读器，支持多种主题，可以直接在终端中阅读 Markdown 文件。

> 和前面的 [vhs](#vhs) 一样，都是由 [Charm Bracelet](https://charm.sh/) 开发的，因此也是非常好用和好看<Badge text="这很重要" type="info" />的工具。

### typos-cli

<Aside type="info">

- GitHub 仓库：[crate-ci/typos](https://github.com/crate-ci/typos)

</Aside>

总是担心自己的文档或者代码中有拼写错误？`typos-cli` 可以马上帮你检查和纠正，而且还可以自动修复，非常方便。

甚至还有 GitHub Action，可以在你的仓库中自动检查拼写错误。

### tldr

<Aside type="info">

- 主页：[tldr.sh](https://tldr.sh/)
- GitHub 仓库：[tldr-pages/tldr](https://github.com/tldr-pages/tldr)

</Aside>

记不住各种常用命令的用法？没关系，`tldr` 一下，你就知道！

由社区维护的文档库里面包含了各种常用命令的用法，可以直接在终端中查看，非常方便。
既免去了记忆命令的麻烦，也不用每次都去查手册里的用例。

> 也可以尝试 Rust 版本的 [`tealdeer`](https://github.com/tealdeer-rs/tealdeer)，功能一致，但是速度更快、可配置选项更多、支持自定义样式。

### btop++

<Aside type="info">

- GitHub 仓库：[aristocratos/btop](https://github.com/aristocratos/btop)

</Aside>

同样作为一个 `top` 命令的替代品，基本功能与界面外观都和 `bpytop` 保持一致。
但是 `btop++` 在性能和稳定性上均有所提升。

### bpytop <Badge type="caution" text="不再推荐"/>

<Aside type="info">

- GitHub 仓库：[aristocratos/bpytop](https://github.com/aristocratos/bpytop)

</Aside>

一个更现代化的 `top` 命令，支持多种主题，可以直接在终端中显示多种系统资源的使用情况，如 CPU、内存、网络、磁盘、进程信息等。

> 毕竟用 Python 写的，性能上有一定缺陷，同时存在一些 bug（如内存使用量计算等），更推荐同一作者的 [btop++](#btop)。

### bat

<Aside type="info">

- GitHub 仓库：[sharkdp/bat](https://github.com/sharkdp/bat)

</Aside>

一个更现代化的 `cat` 命令，支持语法高亮、行号、Git 仓库中的差异等等。

### delta

<Aside type="info">

- 主页：[dandavison.github.io/delta/](https://dandavison.github.io/delta)
- GitHub 仓库：[dandavison/delta](https://github.com/dandavison/delta)

</Aside>

一个更好看的 `diff` 命令，支持语法高亮、行号、文件夹比较等等功能，同时也支持模拟 `diff-highlight` 和 `diff-so-fancy` 的输出样式。

> 如果是颜值党，强烈推荐使用 `delta` 作为 `git` 和 `jj` 的默认差异显示工具。

### icdiff

<Aside type="info">

- GitHub 仓库：[jeffkaufman/icdiff](https://github.com/jeffkaufman/icdiff)

</Aside>

一个带颜色的 `diff` 命令，可以直接在终端中显示差异。
同时也支持查看 Git 仓库中的更改 `git icdiff`。

### logo-ls

<Aside type="info">

- GitHub 仓库：[Yash-Handa/logo-ls](https://github.com/Yash-Handa/logo-ls) <Badge text="原作者已不再维护" type="caution" />
- 一个继续维护的分支：[canta2899/logo-ls](https://github.com/canta2899/logo-ls)

</Aside>

一个带有图标的 `ls` 命令，可以直接在终端中显示文件和文件夹的图标。

> 由 canta2899 继续维护的分支做了许多调整，比如新增了许多图标、采用最新的 Nerd Font v3 版本，因此更推荐使用该分支。

> 尽管没有进入到各类发行版的官方仓库，但近期作者更新了安装脚本，可以直接获取编译好的二进制文件，不再需要手动编译安装了，十分方便。

### fastfetch

<Aside type="info">

- GitHub 仓库：[fastfetch-cli/fastfetch](https://github.com/fastfetch-cli/fastfetch)

</Aside>

一个更快的 `neofetch`，可以直接在终端中显示系统信息和 ASCII 艺术图，同时也支持更多的功能和配置选项。

> 由于 `neofetch` 已经停止维护，因此 `fastfetch` 是一个很好的替代选择。
> 而且 `fastfetch` 也在各发行版的官方仓库中，安装也十分方便。

## 版本控制

### Jujutsu (jj)

<Aside type="info">

- 主页：[jj-vcs.github.io](https://jj-vcs.github.io/jj/latest/)
- GitHub 仓库：[jj-vcs/jj](https://github.com/jj-vcs/jj)

</Aside>

一个新兴的版本管理控制系统，目前使用 `git` 作为后端，可以兼容已经使用 `git` 管理的项目。

亮眼之处在于其设计理念，更加围绕<Ruby rb="提交" rt="commit"/>进行设计，而不是像 `git` 那样围绕<Ruby rb="分支" rt="branch"/>进行设计。

- 消除了暂存区：所有的修改都将直接作为当前提交的一部分，同时不再要求提交必须有描述，可以将提交作为快照进行“暂存”。
  所有提交节点形成一个树形结构，根节点固定为一个不可变的空节点。
- 消除了分支：取而代之的是<Ruby rb="书签" rt="bookmark" />。
  书签可以随时移动到任何一个提交上，从根节点出发到该提交的路径即构成了兼容 Git 的分支提交历史。
- 提交节点高度可变：你可以随时进入特定提交，查看和修改其内容，或是修改其描述。
- 提交历史高度可变：你也可以随时修改提交历史结构，将一个子树移动到另一个位置，调整节点的顺序，或者直接抛弃不需要的节点。
- 简单的冲突处理：如果你通过修改历史节点或者变基等方式引入了冲突，系统会自动检测影响的提交并提示你处理。
  只修改修改冲突所在提交即可。
- 与远程 `git` 仓库的兼容性：支持与远程 `git` 仓库的交互，可以方便地推送和拉取代码。
  不过为了避免强制推送，远程仓库的提交历史对应的节点均会被标记为不可变，防止意外修改。

> <Ruby rb="呪術" rt="じゅじゅつ" /> 还是
> <Ruby rb="柔術" rt="じゅうじゅつ" /> ？这是一个问题

> 目前仍然在积极开发中，但个人认为已经可以用于生产环境了。

> 得益于完全不同于 `git` 的设计理念，不再需要纠结为每个提交取名，也可以快速测试一些简单修改而不需要新建分支。
> 同时也能很方便地修改提交历史和描述，相比于 `git` 要直观很多。

### jjui

<Aside type="info">

- 主页：[idursun.github.io/jjui](https://idursun.github.io/jjui/)
- GitHub 仓库：[idursun/jjui](https://github.com/idursun/jjui)

</Aside>

一个基于 TUI 的 `jj` 图形化界面，可以方便地查看和管理 `jj` 仓库。

> 很好地解决了记不住 `jj` 命令的问题，同时非常直观地展示了仓库的状态和历史。
> 毫不夸张地说，让 `jj` 的上手难度下降了一个数量级。

> 如果你考虑尝试 `jj`，请务必搭配 `jjui`。

### tig

<Aside type="info">

- GitHub 仓库：[jonas/tig](https://github.com/jonas/tig)

</Aside>

命令行下的 Git 客户端，可以直接在终端中查看 Git 仓库的状态、分支图、提交历史、文件差异等等。

### gitui

<Aside type="info">

- GitHub 仓库：[extrawurst/gitui](https://github.com/extrawurst/gitui)

</Aside>

另一个命令行下的 Git 客户端，基于 Rust，支持多平台。
在提供了相当丰富的功能的同时还减少了内存占用和启动时间（相比于 tig 和 lazygit）。
并且键位绑定相对更加符合直觉。

## 编辑器

### VSCode

<Aside type="info">

- 主页：[code.visualstudio.com](https://code.visualstudio.com/)
- GitHub 仓库：[microsoft/vscode](https://github.com/microsoft/vscode)

</Aside>

非常轻量级的编辑器，但是有非常强大的插件系统，可以满足各种需求，妥妥的第一选择。

> 好用到什么程度？除了 VSCode 我可以不用任何其他编辑器，就能够完成所有的工作。<Badge text="当然剪视频/看网页啥的不算" type="caution" />

### Cursor <Badge text="不再推荐" type="caution" />

<Aside type="info">

- 主页：[cursor.so](https://cursor.so/)
- GitHub 仓库：[getcursor/cursor](https://github.com/getcursor/cursor)

</Aside>

非常有前途的后起之秀，主打的就是 GPT-4 进行生成、聊代码、debug 等 AI 辅助功能，比目前 GitHub Copilot 用的模型更新，因此不管是生成速度还是质量上都压过一头。

> 虽然目前仍然在积极开发中，但是最近套壳了 VSCode，接入了庞大的插件生态，因此一下子可以进入第一梯队了，值得后续持续关注。

### SpaceVim <Badge text="更推荐 AstroNvim" type="tip" />

<Aside type="info">

- 主页：[spacevim.org](https://spacevim.org/)
- GitHub 仓库：[SpaceVim/SpaceVim](https://github.com/SpaceVim/SpaceVim)

</Aside>

一个基于 Vim 或者 NeoVim<Badge text="推荐" type="tip" /> 的编辑器。
如果你像我一样不愿意折腾 Vim 的配置，更希望一个配置相对简单但绝不牺牲功能性的编辑器，那么就可以试试 SpaceVim。

> 模块化是最大的优点，只需要简单的几行配置就能启用或禁用某个模块，而且还能自定义模块的配置。
> 界面也很好看，有多种主题可供选择。
> 作为图形化编辑器的临时替代或者主力编辑器都非常不错。

> 如果想要更进一步精简配置，做到开箱即用，你也可以尝试 [Helix](https://github.com/helix-editor/helix)，或许会适合你。

### AstroNvim

<Aside type="info">

- 主页：[astronvim.com](https://astronvim.com/)
- GitHub 仓库：[AstroNvim/AstroNvim](https://github.com/AstroNvim/AstroNvim)

</Aside>

一个基于 NeoVim 的编辑器。
相比于 SpaceVim，AstroNvim 更加注重可拓展性与易用性。
对于希望开箱即用的用户，[AstroCommunity](https://github.com/AstroNvim/AstroCommunity) 提供了许多预配置的插件（包），可以通过修改一行配置来快速启动。
同时支持基于 lazy.nvim 的插件管理，可以相对便捷地添加 AstroCommunity 未提供的插件。

> AstroNvim 更适合对于 Vim/NeoVim 有一定了解的用户，因为它更加注重可拓展性，因此需要一定的配置才能发挥其最大的作用。
> 但其提供的教程，以及丰富到基本不需要自行添加配置的社区插件（包），都尽可能降低了上手的门槛。

> 最近 AstroNvim 上线了[社区插件页面](https://astronvim.github.io/astrocommunity/)，可以直接在文档中搜索和浏览插件，极大地方便了用户的使用。

### Warp <Badge text="不再推荐" type="caution" />

<Aside type="info">

- 主页：[warp.dev](https://warp.dev/)
- GitHub 仓库：[warpdotdev/warp](https://github.com/warpdotdev/Warp)

</Aside>

谁说终端不能是一个编辑器呢？Warp 就是，不仅可以像终端一样使用，还可以像编辑器一样方便地编辑多行命令。
并且支持命令分块，可以很方便的追溯历史记录或输出。
同时还提供了 AI 辅助功能，可以根据自然语言生成命令，非常方便。

> 历经更新后总算实现了跨平台支持。
> 但是放在当下各类大模型都推出了自家的命令行工具的情况下，我觉得 Warp 的竞争力也相对有限。

### CodeEdit <Badge type="caution" text="不再推荐" />

<Aside type="info">

- 主页：[codeedit.app](https://codeedit.app/)
- GitHub 仓库：[CodeEditApp/CodeEdit](https://github.com/CodeEditApp/CodeEdit)

</Aside>

主打复刻 Xcode 的编辑器，但要比 Xcode 更轻量级，而且还支持多种语言。
力图为开发者提供一个和 Xcode 类似但更普适的编辑器。

> 作为几乎从诞生起就一直关注的项目，我本来是很期待的，但是开发速度实在是太慢了。
> 并且相比于做出一个“能用”的编辑器，团队的重心似乎更多地放在了“更原汁原味”的 UI 上，因此目前的体验基本上可以说只有一个空壳，距离其画下的大饼还有很长的路要走。

> 寒假当中的一段时间甚至因为团队内部的不和谐导致分裂出了一个类似的项目 [AuroraEditor](https://github.com/AuroraEditor/AuroraEditor)，开发速度一度超越了 CodeEdit，并且率先一步推出了能够安装使用的版本，但是后来又合并回去了。

> 再加上本身 Swift 语言就决定了要困在苹果的生态内，因此我觉得 CodeEdit 的前景并不是很好，不过也不排除有一天能够成为一个 macOS 上非常好用的编辑器，因此还需要耐心，非常多的耐心来看。

## 网页

### marimo

<Aside type="info">

- 主页：[marimo.io](https://marimo.io/)
- GitHub 仓库：[marimo-team/marimo](https://github.com/marimo-team/marimo)

</Aside>

一个介于 Jupyter Notebook 和 Streamlit 之间的框架，主要功能是作为笔记本（类似于 Jupyter Notebook），但同时支持将笔记本转化为网页应用（类似于 Streamlit）。

优点在于其独特的变量依赖处理，会为你自动维护一个无环依赖图。
每个单元格内所有非私有的变量、函数、类等都会被导出，所使用的非局部变量等也会被追踪。
当上游发生变化时，会自动更新下游所有有依赖关系的单元格，实现了响应性和高性能。

> 如此一来，你可以不用像在 Jupyter Notebook 中那样手动运行某些单元格来避免重复进行耗时操作。
> 也不会像 Streamlit 那样需要重新运行所有代码来更新页面。

> 虽然并不是专门为了做网页应用的框架，不过目前也没有更适合它的分类了，因此暂时放在这儿吧。

### Streamlit

<Aside type="info">

- 主页：[streamlit.io](https://streamlit.io/)
- GitHub 仓库：[streamlit/streamlit](https://github.com/streamlit/streamlit)

</Aside>

一个非常好用的 Python Web 框架，可以用来快速搭建一个网页应用。
丰富的 API，可以很方便地实现各种功能，比如绘图、文件上传下载、表格展示等等。

> 玩法很多，而且第三方的组件生态也很丰富，可以满足各种需求。
> 平时用于搭建简单的单页应用，或者用于快速展示一些数据，非常方便。
> 重点是还有社区云服务器可以白嫖，可以直接部署到云端，只要是公开仓库就不限数量<Badge text="全体起立" type="info" />，非常方便。

### Nuxt

<Aside type="info">

- 主页：[nuxtjs.org](https://nuxtjs.org/)
- GitHub 仓库：[nuxt/nuxt](https://github.com/nuxt/nuxt)

</Aside>

类似于 Next.js 之于 React，Nuxt 框架很好地优化了 Vue.js 的开发体验，新增了很多实用功能，比如自动导入、基于文件路径的路由、代码分割、多种渲染模式等等。
并且有很多优秀的官方以及社区插件可以使用，同时对于那些只支持 Vue 的插件，也可以正常使用。

> 总结来说，Nuxt 已经是一个相当成熟且生态丰富的框架，适合各种规模的项目。
> 如果你已经熟悉了 Vue 的语法，那么学习 Nuxt 并不难，并且可以很快上手。
> 优秀的文档和社区支持也是 Nuxt 的一大优势，十分适合作为网页开发的首选。

### Vue 3

<Aside type="info">

- 主页：[vuejs.org](https://vuejs.org/)
- GitHub 仓库：[vuejs/core](https://github.com/vuejs/core)

</Aside>

主流前端框架，不用多说，GitHub 上的星标数会说明一切。

> 良好的生态，丰富的插件，以及 Vue 3 的 Composition API，让 Vue 3 成为了一个非常好用的框架，至少在我看来，Vue 3 已经超越了 React，成为了前端开发的首选框架。

### VuePress 2

<Aside type="info">

- 主页：[v2.vuepress.vuejs.org](https://v2.vuepress.vuejs.org/)
- GitHub 仓库：[vuepress/vuepress-next](https://github.com/vuepress/vuepress-next)

</Aside>

基于 Vue 3 的静态网站生成器，支持 Markdown，可以很方便地编写文档或博客，而且还支持 Vue 组件，可以方便地实现各种功能。

> 尽管目前还处于 beta 阶段，但是已经基本稳定，可以预见不会有较大的变动，因此已经可以用于生产环境了。

### Tailwind CSS

<Aside type="info">

- 主页：[tailwindcss.com](https://tailwindcss.com/)
- GitHub 仓库：[tailwindlabs/tailwindcss](https://github.com/tailwindlabs/tailwindcss)

</Aside>

非常好用的原子化 CSS 框架，几乎可以做到不写一行 CSS，并且会根据配置和使用情况自动生成 CSS，因此不会有任何冗余的 CSS 代码，非常用户友好。

> 使用 Tailwind CSS 还可以避免取名的烦恼，也不用担心 CSS 样式的冲突。
> 并且由编辑器提供的自动补全功能，可以很方便地编写 CSS 样式，对我这样的小白来说，不仅可以快速上手，还可以避免很多低级错误，并且根据其功能类对应的实现，进一步学习 CSS 的知识。

> 此外，还有 [tailwind components](https://tailwindcomponents.com/) 这样的社群贡献了大量的组件设计，可以直接套用，非常方便。

## 幻灯片

### Touying

<Aside type="info">

- 主页：[touying-typ.github.io](https://touying-typ.github.io/)
- GitHub 仓库：[touying-typ/touying](https://github.com/touying-typ/touying)

</Aside>

基于 Typst 的幻灯片生成器，类似于 $\LaTeX$ 的 Beamer。

- 相比于 Beamer，Touying 依赖于 Typst，不仅语法简洁，同时也非常好上手，学习成本低。
- 而相比于其他基于 Typst 的幻灯片框架（如 polyux），Touying 也提供了更完善的功能和更好的语法支持，同时包含了数个美观的主题。
  并且 Touying 还和其他一些常用的 Typst 库进行了兼容，可以快速拓展框架的功能，不输 Microsoft Powerpoint。

> 与我个人而言，用了 Touying 之后就再没碰过其他框架。

### Slidev

<Aside type="info">

- 主页：[sli.dev](https://sli.dev/)
- GitHub 仓库：[slidevjs/slidev](https://github.com/slidevjs/slidev)

</Aside>

基于 Vue 3 的幻灯片生成器，使用 Markdown 编写幻灯片，而且还支持 Vue 组件，可以方便地实现各种功能。
生成的幻灯片非常简洁美观，内置的功能也能够满足绝大部分的需求。

> 由于该项目目前仍在开发中，因此还存在一些瑕疵，不过好在开发较为活跃，可以再等一段时间后相对稳定了再使用。

> 对我自己而言，Slidev 使用的 Windi CSS 和/或 Uno CSS 与 Tailwind CSS 还是有一定语法上的出入的，不是非常顺手。
> 更重要的是，其 Markdown 语法格式用到了文内的扉页块，这对于大多数格式化工具而言，都是不支持的，因此在使用过程中，还是会时不时遇到由于顺手格式化了文档而导致的错误。
> 再加上其本身也不能够算得上非常轻量级~~，因此我目前还是使用 [Hope 主题](https://github.com/vuepress-theme-hope/vuepress-theme-hope)整合的基于 Reveal.js 的方式来编写幻灯片~~。
> 不过如果你不想为了编写幻灯片而搭建一个完整的站点<Badge text="为了这点醋才包的一盘饺子" type="info" />，那么 Slidev 本身也是一个不错的选择。

## 文稿

### Typst

<Aside type="info">

- 主页：[typst.app](https://typst.app/)
- GitHub 仓库：[typst/typst](https://github.com/typst/typst)

</Aside>

一个功能强大可比 $\LaTeX$，同时语法简洁的现代排版系统。
附带了多种函数来提供更丰富的功能性拓展，甚至还支持简单的脚本允许你自行编写规则。

> 如果要我说最讨厌 $\LaTeX$ 的一点，那莫过于其语法的复杂性了。
> 而 Typst 不仅功能强大、语法简洁，还得益于其 Rust 编译器内核的高效性，Typst 的编译 PDF 速度也非常快，即便是从头生成，也不过一眨眼的事情，更不用说还提供了增量编译来实时预览了，睥睨 Microsoft Word 和 Markdown 那样的所见即所得。

> 如果你不愿意本地安装，也可以直接使用在线的编辑器来编写文档，依然可以享受自动补全和实时预览带来的顶级体验。<Badge text="完全符合我对现代排版系统的想象" type="info" />

> 比较有争议的点可能在于数学公式采用了一套自己的语法，而不是大量借鉴 $\LaTeX$ 的语法，这可能会让一些人从 $\LaTeX$ 迁移过来时感到不适应，也是很多人批评它的地方。
> 不过我认为这个见仁见智，这样做的好处是可以让 Typst 的语法更加简单，而且在 VSCode 插件的自动补全功能的加持下，似乎也不是什么大问题，这点学习新语法的成本远低于其收益，非常划得来。

> Typst 迅速发展起来的社区生态（比如这个 [awesome list](https://github.com/qjcg/awesome-typst)），也反映出了其在不断地吸引新用户，这也是我非常看好它的原因之一。

### Zathura

<Aside type="info">

- 主页：[pwmt.org/projects/zathura](https://pwmt.org/projects/zathura/)
- GitLab 仓库：[pwmt/zathura](https://git.pwmt.org/pwmt/zathura)

</Aside>

一个非常轻量级的 PDF 阅读器，支持多种插件。<Badge text="干翻Acrobat！" type="info" />

> 支持 Vim 的键位绑定，并且命令行友好，非常适合 Vim 用户。

> 支持颜色配置，可以根据喜好对文档进行重新着色，再也不用担心长期盯着白花花的 PDF 看眼睛疼了。

> 缺点可能在于缺少部分高级功能，比如注释、标注等等，但是对于一般的阅读需求，已经足够了。

### Skim

<Aside type="info">

- 主页：[skim-app.sourceforge.io](https://skim-app.sourceforge.io/)
- SourceForge 项目：[skim-app](https://sourceforge.net/projects/skim-app)

</Aside>

一个 macOS 上轻量级的 PDF 阅读器，专注于提供高效的文档浏览体验。
同时支持很多实用的功能，比如笔记和高亮、幻灯片模式、同步（LaTeX、SyncTeX、PDFSync）等等。

省流：**界面简洁**、**功能丰富**、**飞速启动**、**免费开源**。

> 不用更多介绍了吧，Adobe Acrobat Reader 你就学吧，学无止境啊。

## 图像

### Inkscape

<Aside type="info">

- 主页：[inkscape.org](https://inkscape.org/)
- GitHub 仓库：[inkscape/inkscape](https://github.com/inkscape/inkscape)

</Aside>

一个非常好用的矢量图形编辑器，支持多种格式的导入和导出，包括 SVG、PDF 等。

> Inkscape 不仅仅是 Adobe Illustrator 的替代品，还有一些功能是 Illustrator 没有的，比如在导入 PDF 时正确绘制缺少的字体。
>
> 对于习惯了 Adobe Illustrator 的用户来说，Inkscape 的学习曲线可能会比较陡峭。
> 许多键位绑定<Badge text="即便选择了 Illustrator 键位映射" type="info" />和功能布局不尽相同，但是只要克服了这一点，Inkscape 也是一个非常好用的工具。

### draw.io

<Aside type="info">

- 主页：[www.drawio.com](https://www.drawio.com/)
- GitHub 仓库：[jgraph/drawio](https://github.com/jgraph/drawio)

</Aside>

一个在线矢量图形编辑器，界面简洁明了，功能强大。
内置了很多模板和图形库，可以快速上手，满足大部分的绘图需求。
还支持多种格式的导出，包括 SVG、PDF 等。

最最关键的是人家一直**免费**啊，相比于某些动辄收费甚至订阅制的工具，简直良心。

> 画流程图、架构图都是一把好手。
> 并且还支持渲染 $\LaTeX$ 的数学语法，可以在画图时轻松插入复杂的数学表达式。

> 不知道为啥之前把它给忘了，没它的话论文插图都不知道怎么搞。

## 字体

### Maple

<Aside type="info">

- 主页：[font.subf.dev](https://font.subf.dev/)
- GitHub 仓库：[subframe7536/maple-font](https://github.com/subframe7536/maple-font)

</Aside>

一个带 CJK 字符、中英文 2:1 宽度的圆角等宽字体，字体宽度合适，并且包含了 Nerd Fonts 以及连字等等特性。

> 总体设计非常优秀，字符表比较全，也有优美的英文斜体和连字，看起来非常舒服，十分适合编辑器和终端使用。

> 虽然也完全可以用于日常阅读，但看久了可能会审美疲劳。<Badge type="info" text="为了保持 2:1 的宽度比，中文字距会稍微大一些" />
